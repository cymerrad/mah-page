module Flies where

import Prelude

import Data.Array (take)
import Data.Foldable (foldMap)
import Data.Unfoldable (replicateA)
import Partial.Unsafe (unsafePartial)
import Data.Maybe (Maybe(..), fromJust)
import Math (Radians, log, cos, sin, sqrt, pi)

import DOM (DOM)
import Control.Timer (TIMER)
import Signal.Channel (CHANNEL)
import Signal.DOM (animationFrame)
import Graphics.Drawing (Point, render)
import Graphics.Canvas (CANVAS, Context2D,
                        getCanvasElementById, getContext2D,
                        getCanvasWidth, getCanvasHeight, clearRect)

import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Random (RANDOM, random, randomRange)

import Flare (UI, runFlareWith, lift, intSlider_, buttons, foldp)
import Flare.Drawing (Drawing, white, fillColor, filled, circle)

type Time = Number
type Velocity = Point

scale :: Number -> Point -> Point
scale s {x: x, y: y} = {x: s*x, y: s*y}
infixr 5 scale as ⋆

rotate :: Point -> Radians -> Point
rotate {x: x, y: y} r = {x: cos r * x - sin r * y, y: sin r * x + cos r * y}
infixr 6 rotate as ∠

unit :: Point -> Point
unit p = (1.0/(sqrt $ p.x*p.x + p.y*p.y)) ⋆ p

type Fly = {p :: Point, v :: Velocity}

fly :: Fly -> Time -> Point
fly {p: p, v: v} t = g t ⋆ p ∠  f t
  where f t = a * log (g t)
        g t = 1.0 + b * t
        a   = (p.x * v.y - p.y * v.x) / (p.x * v.x + p.y * v.y)
        b   = (p.x * v.x + p.y * v.y) / (p.x * p.x + p.y * p.y)

randomFly :: forall eff. Number -> Number -> Eff (random :: RANDOM | eff) Fly
randomFly width height = do
  x <- randomRange (-width/2.0) (width/2.0)
  y <- randomRange (-height/2.0) (height/2.0)
  r <- randomRange (pi/2.0 + 0.05) (pi/2.0 + 0.1)
  c <- random
  let p = {x: x, y: y}
  let v = 0.5 ⋆ unit if c < 0.5 then p ∠  r
                                else p ∠ -r
  pure {p: p, v: v}

drawFlies :: Point -> Array Fly -> Time -> Drawing
drawFlies origin flies time = foldMap makeCircle flies
  where makeCircle f = filled (fillColor white) $ circle (p.x + origin.x) (p.y + origin.y) 2.0
          where p = fly f time

type Model = { context :: Context2D
             , width   :: Number
             , height  :: Number
             , flies   :: Array Fly
             , time    :: Time
             , start   :: Boolean
             , reset   :: Boolean }

controller :: forall eff. Model -> Eff (canvas :: CANVAS | eff) Unit
controller model = do
  clearRect model.context {x: 0.0, y: 0.0, w: model.width, h: model.height}
  render model.context $ filled (fillColor white) $
                         circle (model.width/2.0) (model.height/2.0) 10.0
  render model.context $ drawFlies {x: model.width/2.0, y: model.height/2.0}
                                   model.flies
                                   model.time
data Action = Start | Reset

label :: Action -> String
label Start = "start"
label Reset = "reset"

isAction :: Maybe Action -> Action -> Boolean
isAction (Just a) b = label a == label b
isAction Nothing  _ = false

view :: forall e. Model -> UI (timer :: TIMER | e) Model
view model = state <$> buttons [Start, Reset] label
                   <*> intSlider_ 0 200 20
                   <*> lift animationFrame
  where state action n time = model { flies = take n model.flies
                                    , time  = time
                                    , start = action `isAction` Start
                                    , reset = action `isAction` Reset }

resetView :: forall e. Model -> UI (timer :: TIMER | e) Model
resetView model = foldp acc model $ view model
  where acc ma mb = if not mb.start || ma.reset
                       then ma{start = next, time = 0.0}
                       else ma{start = next, time = ma.time - mb.time}
                    where next = (ma.start || mb.start) && not ma.reset

main :: Eff (dom :: DOM, channel :: CHANNEL, canvas :: CANVAS, timer :: TIMER, random :: RANDOM) Unit
main = do
  canvas      <- getCanvasElementById "output"
  let pcanvas =  unsafePartial $ fromJust canvas
  context     <- getContext2D pcanvas
  width       <- getCanvasWidth pcanvas
  height      <- getCanvasHeight pcanvas
  flies       <- replicateA 200 $ randomFly width height
  runFlareWith "controls" controller $ resetView { context: context
                                                 , width  : width
                                                 , height : height
                                                 , flies  : flies
                                                 , time   : 0.0
                                                 , start  : false
                                                 , reset  : false }